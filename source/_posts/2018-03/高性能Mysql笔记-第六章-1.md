---
title: 高性能Mysql笔记-第六章(1)
date: 2018-03-09 20:44:29
tags: mysql
categories:
- mysql
---

# 第六章 查询性能优化
- 前面章节的内容：
1. 最优库表结构；
2. 最优索引。

- 本章内容：
设计合理的查询。

# 6.1 查询任务的组成
- 查询的生命周期
1. 客户端到服务器；
2. 服务器解析，生成执行计划；
3. 执行；
4. 返回结果给客户端。

其中第三步执行可以分解为：
- 执行： 
1. 检索数据到存储引擎；
2. 数据处理。（排序，分组）

查询时间消耗包括：
- 网络；
- CPU计算；
- 生成统计信息和执行计划；
- 锁等待（互斥等待）；
- 其他。


# 6.2 慢查询基础：优化数据访问
## 6.2.1 减少数据量
慢查询的基本原因之一是数据量太大了，针对这个方面，方法有两个：
1. 减少访问的行数；（使用limit）
2. 减少访问的列数。（利用覆盖索引）

此外，对于重复查询，在应用层进行缓存也是一个比较常见的方法。

## 6.2.2 检查是否扫描了额外的记录
衡量查询开销的三个指标：
1. 响应时间；
2. 扫描和返回的行数；
3. 扫描的行数和访问类型。

### 响应时间
响应时间可分为：
1. 服务时间： 真正处理的时间；
2. 排队时间： 等待资源时的时间。

### 扫描和返回的行数
理想情况：
扫描行数=返回行数。

较短的行代价较小。

## 扫描的行数和访问类型
访问类型：
由`Explain`语句的`type`字段可以得到。包括：
1. ALL，全表扫描；（差）
2. Index,索引扫描；
3. Range,范围扫描；
4. 唯一索引查询；
5. 常数引用。（优）
等等...

访问类型越优，扫描的成本越小。

**预估的扫描行数**
查询优化器预估的扫描行数，可以通过`Explain`语句的`rows`字段得到。

**Where的三种应用方式**
三种方式由好到坏依次为：
1. 索引中使用。在存储引擎层完成；（`Extra`列为空）
2. 使用索引覆盖扫描（`Extra`列出现`Using index`）。扫描后，在服务器层过滤，但不用回表。
3. 不使用索引。从存储引擎返回行，在服务器层过滤。(`Extra`列为`Using Where`)。


相关的查询优化技巧：
1. 覆盖索引；
2. 改变库表结构，使用单独的汇总表；
3. 重写复杂查询。（后续讨论）

# 6.3 重构查询的方式
## 6.3.1 复杂查询分解成多个简单查询
由于现代mysql的连接更轻量，网速也更快，因此分解复杂大查询成简单小查询也是很有必要的。
（也要适度权衡，不能过度分解）

## 6.3.2 切分查询
一个简单查询，但锁住大量行，可以分解成几个锁住少量行的查询，分时间段执行，减轻服务器瞬发压力。
比如删除100万行数据，可以分成删除100个1万行数据。


## 6.3.3 分解关联查询
分解关联查询后，在应用层做关联。
- 原查询
```
select *
from tag
join tag_post on tagid=id
join post on post.tagid=id
where tag='mysql'
```

- 分解后：
```
select * from tag where tag='mysql';
select * from tag_post where tagid=1234;
select * from post where id in (1,2,3,4)
```

上述分解的好处：
1. 缓存的效率更高；
2. 分解后，锁竞争更少；（锁粒度更细）
3. 数据库拆分更容易；（不需要跨库查询）
4. 关联可能会更高效；
5. 减少记录的重复查询；
6. 相当于应用中实现了哈希关联（效率高）。

# 6.4 查询执行的基础
查询流程：
1. 客户端：发送查询到服务器；
2. 服务器：检查缓存；
3. 服务器：SQL解析，预处理，优化器生成执行计划；
4. 调用存储引擎的API执行查询；
5. 返回结果给客户端。
{% img /images/query-flow.png 400 600 查询流程 %}


## 6.4.1 Mysql客户端/服务器通信协议
特点：
1. 半双工

优点：
- 简单快捷；

缺点：
- 无法进行流量控制，一旦一端开始发送消息，另一端要完整接收后才能响应它。


1. 服务器端：
参数`max_allowed_packet`的作用：如果查询太大，服务端会拒绝接收更多的数据。

2. 客户端：
如果服务器发送的数据特别多，客户端必须完整地接收完整个结果。粗暴地断开连接不是个好主意，应该使用Limit进行限制。
服务器端发送完全部数据，才会释放相应资源。

**查询状态**
相关命令：
```
SHOW FULL processlist;
```
相关状态值含义：
1. `Sleep`: 等待客户端发送请求；
2. `Query`：正在执行或发送结果；
3. `Locked`:（`MyIsam`有，`Innodb`没有） 服务器层，线程等待表锁；（行锁等存储引擎级别的锁不会体现在这里。）
4. `Analyzing and statistics`: 线程正在收集存储引擎的统计信息，并声称查询的执行计划。
5. `Copying to tmp table[on disk]`： 线程正在执行查询，并且将其结果集都复制到一个临时表中。可能的操作包括： (1) `GROUP BY`；(2) 文件排序；(3) UNION操作。
6. `Sorting result`: 对结果集进行排序；
7. `Sending data`: (1)多个状态之间传送数据；
(2)生成结果集中；
(3)向客户端返回数据。