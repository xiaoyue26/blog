---
title: 高性能Mysql笔记-第五章(2)
date: 2018-03-03 17:11:25
tags: mysql
categories:
- mysql

---

## 5.3.7 使用索引扫描来做排序
Mysql生成有序结果的两种方法: (详见第7章)
1. 排序操作. 
2. 按索引顺序扫描.

// explain结果中的type,如果为`index`,则使用第二种方法,按索引顺序扫描.
按索引顺序扫描工作流程:(Innodb二级索引)
1. 顺序扫描索引,获取主键指针;
2. 回表查询相应主键的数据行.
如果索引是覆盖索引,则可以避免上述第二步,减少一次磁盘IO,并且避免大范围扫描时的大量随机IO.

**正确示例:**
**索引为(a,b,c)**
示例1:
```
select a,b,c from t
where a='xxx' ORDER BY b,c
```
组合where条件和order by条件,而且都是顺序(ASC). 此外如果组合后是索引的最左前缀,也是可以利用索引进行排序的.

**错误示例**
示例2:
```
select a,b,c from t
where a='xxx' order by b DESC,c ASC.
```
由于顺序和建立索引的不同,因此不能利用到索引进行排序.
如果需要按不同方向排序, 可以通过存储这列的相反数或者反转值, 满足这种需求.

示例3:
```
select a,b,c from t
where a>'xxx' order by b,c
```
由于a是范围查询,因此无法利用索引的其他列(b和c).


## 5.3.8 压缩(前缀压缩)索引
```
仅对于MyISAM引擎.
```
`MyISAM`使用前缀压缩来减少索引的大小,从而让更多的索引可以放入内存中.

- 压缩对象:
```
1. 字符串(默认设置)
2. 整数(用参数设置)
```

- 压缩方法:
```
1. 完全保存索引块的第一个值;
2. 从第二个值开始,保存:(相同前缀字节数,剩余部分)

例如原始数据为:
1. perform
2. performance

压缩后:
1. perform (完整保存)
2. 7,ance  (相同前缀字节数,剩余部分)
```

- 压缩优点:
使用更少空间;

- 压缩缺点:
某些操作变慢: 因为每个值的压缩前缀都依赖前面的值,所以MyISAM查找时无法二分查找. 正序扫描不受影响,倒序扫描性能变慢.
块中查找某一行的平均耗时: 扫描半个索引块. 

- 压缩索引使用场景:
IO密集型查询.(减少传输量,可能只需要1/10的磁盘大小)

- 压缩索引不适用的场景:
CPU密集型查询.(因为扫描需要随机查找)

## 5.3.9 冗余和重复索引
- 背景: 
MySQL允许在列上创建多个索引.

- 重复索引:
相同列,顺序相同,类型相同的索引.
(例: 同一列上建立主键和唯一索引,事实上唯一限制和主键限制都是通过索引实现的,事实上建立了重复索引)

- 冗余索引:
前缀索引与索引冗余. 
(例: 索引(A,B)与索引(A)冗余.)

处理:
1. 重复索引应该移除;
2. 冗余索引应该考虑移除:
(1) 如果原来的索引已经太长到影响性能,可以保留冗余索引
(2) 如果(1)不成立,应该尽量移除冗余索引.


索引太多的缺点:
1. 写入速度变慢;(可以通过禁用索引,然后延迟build索引优化)
2. 查询时mysql需要选择索引,索引多的话需要比较的索引也变多,影响查询计划的
生成速度.
3. 存储索引成本增加.


## 5.3.10 未使用的索引
检查各个索引的使用频率:
1. 打开userstates参数;(默认是关闭的)
2. mysql服务器正常运行一段时间;(可以考虑使用benchmark)
3. 查询Information_schema.Index_statistics,查到每个索引的使用频率.

## 5.3.11 索引和锁
```
以下讨论Innodb引擎
```

索引可以让查询锁定更少的行:
1. 减少内存使用;
2. 减少锁争用,提高并发度.

早期Mysql:
事务提交后才释放锁;

新版本Mysql:
服务器端过滤掉行后,释放没用到的行锁.